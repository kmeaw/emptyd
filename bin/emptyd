#!/usr/bin/env ruby
# vim: ai:ts=2:sw=2:et:syntax=ruby

lp = File.expand_path(File.join(File.dirname(File.realpath(__FILE__)), "..", "lib"))

unless $LOAD_PATH.include?(lp)
  $LOAD_PATH.unshift(lp)
end

require "emptyd"
require 'evma_httpserver'

class MyHttpServer < EM::Connection
  include EM::HttpServer

  def initialize(logger)
    @logger = logger
  end

  def post_init
    super
    no_environment_strings
  end

  def process_http_request
    done = false
    port, ip = Socket.unpack_sockaddr_in(get_peername)
    @logger.info "#{ip}:#{port} #{@http_request_method} #{@http_path_info} #{@http_post_content.inspect}"

    response = EM::DelegatedHttpResponse.new(self)
    response.status = 200
    response.content_type 'application/json'
    response.content = JSON.dump({ :okay => true })

    begin
      case @http_path_info
      when %r{/ping}
        # nop
      when %r{/session/new}
        session = Emptyd::Session.new JSON.parse(@http_post_content, :symbolize_names => true).merge(:logger => @logger)
        response.content = JSON.dump({id: session.uuid})
      when %r{/session/(.*)/run}
        Emptyd::Session[$1].run @http_post_content
      when %r{/session/(.*)/read}
        session = Emptyd::Session[$1]
        if session.dead? and session.queue.empty?
          session.destroy!
          response.content = JSON.dump([nil,:dead,nil])
        else
          return session.queue.pop do |data|
            if data[-1].kind_of? String
              data[-1].force_encoding Encoding::UTF_8
            end
            response.content = JSON.dump(data)
            response.send_response
          end
        end
      when %r{/session/(.*)/write/(.*)}
        session = Emptyd::Session[$1]
        session.write $2, @http_post_content
      when %r{/session/(.*)/write}
        session = Emptyd::Session[$1]
        session << @http_post_content
      when %r{/session/(.*)/terminate}
        session = Emptyd::Session[$1]
        session.terminate @http_post_content
      when %r{/session/(.*)}
        session = Emptyd::Session[$1]
        case @http_request_method
        when "GET"
          response.content = JSON.dump(session.status)
        when "DELETE"
          session.destroy
        end
      when %r{/session}
        response.content = JSON.dump(Emptyd::Session.ids)
      else
        raise KeyError
      end
    rescue KeyError
      response.content = JSON.dump({:okay => false, :error => :not_found})
      response.status = 404
    end
    response.send_response
  end
end

CONFIG = {
  :server => "::1",
  :server_port => 53353
}

%w{.emptyd.conf .empty.conf}.map{|name| File.expand_path("~/#{name}")}.each do |name|
  next unless File.exist? name
  File.open(name) do |file|
    CONFIG.merge!(JSON.parse(file.read, :symbolize_names => true)) do |k, x, y| 
      x.respond_to?(:merge) ? x.merge(y) : y
    end
  end
end

# XXX: We need a shared environment for Session and Connection
$PASSWORD = CONFIG[:password]

EM.run do
  $0 = "emptyd"
  logger = Logger.new(STDOUT)
  EM.start_server CONFIG[:server], CONFIG[:server_port], MyHttpServer, logger
  logger.info "Server started on #{CONFIG[:server]}, port #{CONFIG[:server_port]}."
end

